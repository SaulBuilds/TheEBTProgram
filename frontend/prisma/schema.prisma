generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ==================== USER & APPLICATION ====================

model User {
  id           Int           @id @default(autoincrement())
  username     String        @unique
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  applications Application[]
}

model Application {
  id            Int       @id @default(autoincrement())
  userId        String    @unique
  username      String    @unique
  walletAddress String
  profilePicURL String?

  // Privy authentication ID - prevents same Privy account from creating multiple apps
  privyUserId   String?   @unique

  // Social connections (from Privy)
  twitter       String?   // Twitter handle
  discord       String?   // Discord username
  telegram      String?   // Telegram username
  github        String?   // GitHub username
  email         String?   // Email address

  // Application data
  zipCode       String?
  hungerLevel   String?
  monthlyIncome String?
  dependents    Int       @default(0)

  // Scoring
  score         Int       @default(0)
  scoreBreakdown String?  // JSON string of score breakdown

  // Status flow: pending -> approved -> minted
  status        String    @default("pending")
  metadataURI   String?   // IPFS URI set at approval time
  imageURI      String?   // IPFS URI for the generated card image

  // Mint tracking
  mintedTokenId Int?      @unique
  approvedAt    DateTime?
  appliedAt     DateTime  @default(now())

  // Relations
  user          User?     @relation(fields: [userRef], references: [id])
  userRef       Int?
  mints         Mint[]

  // Rejection reason (if rejected)
  rejectionReason String?

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Wallet snapshot at application time
  walletSnapshot WalletSnapshot?

  // Generated card
  generatedCard  GeneratedCard?
}

model Mint {
  id             Int         @id @default(autoincrement())
  tokenId        Int         @unique
  userId         String
  accountAddress String?     // ERC-6551 token-bound account
  metadataURI    String?
  metadata       String?     // JSON string of metadata
  txHash         String?     // Transaction hash
  mintedAt       DateTime    @default(now())
  application    Application @relation(fields: [applicationId], references: [id])
  applicationId  Int
}

// ==================== SCORING CONFIGURATION ====================

model ScoringConfig {
  id          Int      @id @default(autoincrement())
  name        String   @unique  // e.g., "twitter_connected", "nft_boost", "token_liquidity"
  description String?
  weight      Int      @default(100)  // Points for this metric
  enabled     Boolean  @default(true)
  category    String   // "social", "wallet", "nft", "token"
  metadata    String?  // JSON string for additional config (e.g., min values, thresholds)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// ==================== NFT BOOST CONFIGURATION ====================

model NFTBoostConfig {
  id              Int      @id @default(autoincrement())
  contractAddress String   @unique  // NFT contract address (checksummed)
  chainId         Int      @default(11155111)  // Chain ID (default Sepolia)
  name            String   // Display name (e.g., "Bored Ape Yacht Club")
  symbol          String?  // Token symbol
  boostPoints     Int      @default(100)  // Points for holding this NFT
  minBalance      Int      @default(1)    // Minimum tokens to qualify
  maxBoost        Int?     // Maximum boost (cap for whales)
  enabled         Boolean  @default(true)
  imageURL        String?  // Logo/image for display
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// ==================== TOKEN BOOST CONFIGURATION ====================

model TokenBoostConfig {
  id                  Int      @id @default(autoincrement())
  contractAddress     String   @unique  // ERC20 token contract address
  chainId             Int      @default(11155111)
  name                String   // Token name
  symbol              String?  // Token symbol (optional)
  boostPoints         Int      @default(50)   // Points for holding this token
  minBalanceUSD       Float    @default(100)  // Minimum USD value to qualify
  minLiquidityUSD     Float    @default(5000) // Minimum liquidity on Uniswap
  enabled             Boolean  @default(true)
  imageURL            String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

// ==================== WALLET SNAPSHOT ====================

model WalletSnapshot {
  id            Int         @id @default(autoincrement())
  applicationId Int         @unique
  application   Application @relation(fields: [applicationId], references: [id])

  // ETH balance
  ethBalance    String      // In wei (stored as string for precision)

  // NFT holdings that qualify for boosts (JSON string)
  nftHoldings   String?     // JSON array of {contractAddress, tokenIds[], balance}

  // Token holdings that qualify for boosts (JSON string)
  tokenHoldings String?     // JSON array of {contractAddress, balance, usdValue}

  // Computed boosts
  nftBoostTotal   Int       @default(0)
  tokenBoostTotal Int       @default(0)

  snapshotAt    DateTime    @default(now())
}

// ==================== BACKGROUND THEMES ====================

model BackgroundTheme {
  id          Int      @id @default(autoincrement())
  name        String   @unique  // e.g., "rust_belt", "trailer_park", "urban_decay"
  description String?
  zipPatterns String   // JSON array of zip code patterns (e.g., '["481*", "482*"]' for Detroit)
  promptHints String   // Hints for DALL-E generation
  enabled     Boolean  @default(true)
  createdAt   DateTime @default(now())
}

// ==================== GENERATED CARDS ====================

model GeneratedCard {
  id            Int         @id @default(autoincrement())
  applicationId Int         @unique
  application   Application @relation(fields: [applicationId], references: [id])

  imageCid      String      // IPFS CID for image
  metadataCid   String      // IPFS CID for metadata JSON
  imageUrl      String      // ipfs:// URL for image
  metadataUrl   String      // ipfs:// URL for metadata

  // Generation inputs
  prompt        String?     // The prompt used for generation
  theme         String?     // Background theme used
  badges        String?     // JSON array of badges earned

  // Traits for NFT metadata
  traits        String?     // JSON array of {trait_type, value}

  generatedAt   DateTime    @default(now())
}

// ==================== SLOT MACHINE STATS ====================

model SlotStats {
  id              Int       @id @default(autoincrement())

  // Link to application (user must be on leaderboard to play)
  applicationId   Int       @unique
  userId          String    @unique  // Match the Application.userId

  // Lifetime stats
  totalSpins      Int       @default(0)
  totalWins       Int       @default(0)
  totalPoints     Int       @default(0)
  biggestWin      Int       @default(0)

  // Bonus tracking
  freeSpinsWon    Int       @default(0)
  holdSpinsWon    Int       @default(0)

  // Grand prize tracking
  grandWins       Int       @default(0)
  pendingAirdrop  Boolean   @default(false)  // Flag for 2 ETH airdrop
  airdropClaimed  Boolean   @default(false)
  airdropTxHash   String?   // Transaction hash when airdrop is sent

  // Session tracking
  lastPlayedAt    DateTime?
  currentStreak   Int       @default(0)  // Consecutive winning spins
  bestStreak      Int       @default(0)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

// Track individual spin history (for verification/auditing)
model SlotSpin {
  id              Int       @id @default(autoincrement())
  userId          String

  // Spin details
  spinType        String    @default("base")  // "base", "free", "hold"
  betAmount       Int       @default(0)       // If we add betting later
  winAmount       Int       @default(0)
  cascadeCount    Int       @default(0)

  // Special events
  triggeredBonus  String?   // "freespins", "holdspin", null
  isGrandWin      Boolean   @default(false)

  // Audit trail
  gridHash        String?   // Hash of initial grid for verification
  resultHash      String?   // Hash of result for verification

  spunAt          DateTime  @default(now())
}

// ==================== MEME GENERATION PIPELINE ====================

// System prompts configurable from admin panel
model MemePrompt {
  id              Int       @id @default(autoincrement())
  name            String    @unique  // e.g., "global_style", "card_background", "referral_fomo"
  promptType      String    // "global", "card_background", "referral", "public_meme"
  systemPrompt    String    @db.Text  // The actual prompt text
  description     String?   // Admin description of what this prompt does
  enabled         Boolean   @default(true)
  priority        Int       @default(0)  // Higher priority prompts used first

  // Generation settings
  model           String    @default("gemini-2.0-flash-exp")  // AI model to use
  aspectRatio     String    @default("16:9")  // Image aspect ratio
  negativePrompt  String?   @db.Text  // What to avoid

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relation to generated images
  generations     MemeGeneration[]
}

// Track all generated memes (for rate limiting and history)
model MemeGeneration {
  id              Int       @id @default(autoincrement())

  // User tracking (can be null for anonymous)
  userId          String?   // Application.userId if logged in
  walletAddress   String?   // Wallet that generated
  ipAddress       String?   // For anonymous rate limiting

  // Generation details
  promptId        Int?      // Which system prompt was used
  prompt          MemePrompt? @relation(fields: [promptId], references: [id])

  generationType  String    // "public_meme", "card_background", "referral"
  userInput       String?   // Any user-provided input/topic
  fullPrompt      String?   @db.Text  // Complete prompt sent to API

  // Result
  imageUrl        String?   // URL to generated image
  imageCid        String?   // IPFS CID if stored on IPFS
  status          String    @default("pending")  // pending, completed, failed
  errorMessage    String?   // If failed

  // Referral-specific fields
  twitterAvatar   String?   // Twitter avatar URL if used
  referralCode    String?   // Referral link included

  // Metadata
  generatedAt     DateTime  @default(now())
  processingTime  Int?      // Milliseconds to generate
}

// Daily usage tracking for rate limiting
model MemeUsage {
  id              Int       @id @default(autoincrement())

  // Identifier (userId, walletAddress, or ipAddress)
  identifier      String
  identifierType  String    // "user", "wallet", "ip"

  // Daily counts
  date            DateTime  @db.Date
  generationCount Int       @default(0)

  // Compound unique constraint for daily tracking
  @@unique([identifier, identifierType, date])
}
